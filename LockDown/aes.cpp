#include <io.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <Windows.h>

#define BLOCK_SIZE 16
#define BLOCK_SIZE_ROW 4
#define BLOCK_SIZE_COLUMN 4
#define KEY_ROUND_AMOUNT 10

void AES_Subbytes(unsigned int arr[BLOCK_SIZE_ROW][BLOCK_SIZE_ROW], unsigned int isRotWordCreate);
void AES_inv_Subbytes(unsigned int arr[BLOCK_SIZE_ROW][BLOCK_SIZE_ROW]);

void shiftRowHelper(unsigned int arr[BLOCK_SIZE_ROW][BLOCK_SIZE_ROW], int isLeft);
void AES_ShiftRows(unsigned int arr[BLOCK_SIZE_ROW][BLOCK_SIZE_ROW]);
void AES_InvShiftRows(unsigned int arr[BLOCK_SIZE_ROW][BLOCK_SIZE_ROW]);

void AES_MixColumns(unsigned int arr[BLOCK_SIZE_ROW][BLOCK_SIZE_ROW], unsigned int newMat[BLOCK_SIZE_ROW][BLOCK_SIZE_ROW], unsigned int isInverse);

void KeySchedule(unsigned int key[BLOCK_SIZE_ROW][BLOCK_SIZE_COLUMN], unsigned int roundNumber, unsigned int final_round_key[BLOCK_SIZE_ROW][BLOCK_SIZE_COLUMN]);
void AES_AddRoundKey(unsigned int data[BLOCK_SIZE_ROW][BLOCK_SIZE_COLUMN], unsigned int roundKey[BLOCK_SIZE_ROW][BLOCK_SIZE_COLUMN]);

void encrypt_data_AES(unsigned int data[BLOCK_SIZE_ROW][BLOCK_SIZE_COLUMN],
    unsigned int iv[BLOCK_SIZE_ROW][BLOCK_SIZE_COLUMN], unsigned int roundKey[BLOCK_SIZE_ROW][BLOCK_SIZE_COLUMN], unsigned int isLastRound);
void decrypt_data_AES(unsigned int data[BLOCK_SIZE_ROW][BLOCK_SIZE_COLUMN],
    unsigned int iv[BLOCK_SIZE_ROW][BLOCK_SIZE_COLUMN], unsigned int roundkey[BLOCK_SIZE_ROW][BLOCK_SIZE_COLUMN], unsigned int isLastRound);

void encryptDecryptFile(char fileName[], unsigned int key[BLOCK_SIZE_ROW][BLOCK_SIZE_COLUMN], unsigned int iv[BLOCK_SIZE_ROW][BLOCK_SIZE_COLUMN],
    unsigned int isEncrypt);

void encrypt_block(unsigned int prevBlock[BLOCK_SIZE_ROW][BLOCK_SIZE_ROW], unsigned int currBlock[BLOCK_SIZE_ROW][BLOCK_SIZE_ROW], unsigned int key[BLOCK_SIZE_ROW][BLOCK_SIZE_ROW]);
void decrypt_block(unsigned int prevBlock[BLOCK_SIZE_ROW][BLOCK_SIZE_ROW], unsigned int currBlock[BLOCK_SIZE_ROW][BLOCK_SIZE_ROW], unsigned int key[BLOCK_SIZE_ROW][BLOCK_SIZE_ROW]);

void addPaddingToFileEnding(HANDLE fileHandler, unsigned int amountOfZerosToAdd);
void writeNewEncData(char* fileName, unsigned char* dataToWrite, unsigned int bytesToWrite, int isEncrypt);

void XOR_Blocks(unsigned int arr[BLOCK_SIZE_ROW][BLOCK_SIZE_ROW], unsigned int arr2[BLOCK_SIZE_ROW][BLOCK_SIZE_ROW]);
void BytesTo_2DArr(unsigned char* bytes, unsigned int arr[BLOCK_SIZE_ROW][BLOCK_SIZE_COLUMN]);
void _2DArrTo_Bytes(unsigned char* bytes, unsigned int arr[BLOCK_SIZE_ROW][BLOCK_SIZE_COLUMN]);


/*
Switching bytes with the correct bytes from the rjinadel substitution box
Input: arr - equivalent to the 4x4 matrix of data(we will put 16 byte information block from the file). isRotWordCreate - if the flag is true it means we need to only xor the first column
output: none(changes the array so no need to return - you do not return arrays)
*/
void AES_Subbytes(unsigned int arr[BLOCK_SIZE_ROW][BLOCK_SIZE_ROW], unsigned int isRotWordCreate)
{
	// note that we can look at this sbox arr as a 2d arr(it is just easier to put it as a 1d arr)
	static const unsigned int sbox[256] = {
		0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
		0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
		0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
		0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
		0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
		0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
		0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
		0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
		0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
		0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
		0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
		0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
		0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
		0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
		0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
		0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 };
	
    // running through all the information block(4x4 matrix) and substituding the bytes
	for (int column = 0; column < BLOCK_SIZE_COLUMN; column++)
	{
		for (int row = 0; row < BLOCK_SIZE_ROW; row++)
		{
			arr[row][column] = sbox[arr[row][column]]; // replacing the val in the arr
		}
		if (isRotWordCreate) 
        {
			return; // exiting function because we only need to substitude the first column
		}
	}
}

/*
This is an inversed version of the sub bytes function
input: 2d arr (data),
output: none(saved in the arr which is sent as parameter)
*/
void AES_inv_Subbytes(unsigned int arr[BLOCK_SIZE_ROW][BLOCK_SIZE_ROW])
{
    unsigned char rsbox[256] =
    { 0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
    0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
    0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
    0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
    0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
    0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
    0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
    0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
    0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
    0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
    0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
    0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
    0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
    0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
    0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
    0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d };

    // running through all the information block(4x4 matrix) and substituding the bytes
    for (int column = 0; column < BLOCK_SIZE_COLUMN; column++)
    {
        for (int row = 0; row < BLOCK_SIZE_ROW; row++)
        {
            arr[row][column] = rsbox[arr[row][column]]; // replacing the val in the arr
        }
    }
}


/*
Helper function that we can use for both shift rows and inv shift rows
Input: arr - curr block, isLeft - flag to check if we need to shift left (for sihft rows) or right (for inv shift rows)
Output: none
*/
void shiftRowHelper(unsigned int arr[BLOCK_SIZE_ROW][BLOCK_SIZE_ROW], int isLeft)
{
    for (int i = 1; i < BLOCK_SIZE_ROW; i++)
    {
        unsigned char temp[BLOCK_SIZE_ROW] = { arr[i][0], arr[i][1], arr[i][2], arr[i][3] };

        for (int j = 0; j < BLOCK_SIZE_ROW; j++)
        {
            arr[i][j] = temp[(isLeft ? (j + i) : (j - i + 4)) % 4];
        }
    }
}

/*
Shifting 2nd row left one time, 3rd row two times and 4th row three times
Input: arr - equivalent to the 4x4 matrix of data(we will put 16 byte information block from the file)
output: none(changes the array so no need to return - you do not return arrays)
*/
void AES_ShiftRows(unsigned int arr[BLOCK_SIZE_ROW][BLOCK_SIZE_ROW])
{
    shiftRowHelper(arr, 1);
}

/*
The inverse version of the Shift_Rows AES function - used in decryption
input: data to inverse shift
output: none(changes the array so no need to return - you do not return arrays)
*/
void AES_InvShiftRows(unsigned int arr[BLOCK_SIZE_ROW][BLOCK_SIZE_ROW])
{
    shiftRowHelper(arr, 0);
}


/*
The function preforms the Mix Columns operation on the data and saves the new data in the newMat variable
input: arr - data to perform on, newMat - 2d arr to save the new data, isInverse - 1/0 -> to know if the function is used in decryption
output: none (saved in the newMat arr sent as param)
*/
void AES_MixColumns(unsigned int arr[BLOCK_SIZE_ROW][BLOCK_SIZE_ROW], unsigned int newMat[BLOCK_SIZE_ROW][BLOCK_SIZE_ROW], unsigned int isInverse)
{
    unsigned int mixColMat[BLOCK_SIZE_ROW][BLOCK_SIZE_ROW] = { {0x02, 0x03, 0x01, 0x01},
                                                                { 0x01, 0x02, 0x03, 0x01 },
                                                                { 0x01, 0x01, 0x02, 0x03 },
                                                                { 0x03, 0x01, 0x01, 0x02 } };

    unsigned int mixColMat_dec[BLOCK_SIZE_ROW][BLOCK_SIZE_COLUMN] = { {0x0e, 0x0b, 0x0d, 0x09},
                                    {0x09, 0x0e, 0x0b, 0x0d},
                                    {0x0d, 0x09, 0x0e, 0x0b},
                                    {0x0b, 0x0d, 0x09, 0x0e} };

    if (isInverse) { // if used in decryption the mixColMat is different
        memcpy(&mixColMat, &mixColMat_dec, BLOCK_SIZE_COLUMN * BLOCK_SIZE_ROW * sizeof(unsigned int));
    }
    // helps with byte multiplication stuff
    static const unsigned int gfMulTable[15][256] = {
        {0},
        {0},    

        // mul 2
        {0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e, 0x10, 0x12, 0x14, 0x16,
         0x18, 0x1a, 0x1c, 0x1e, 0x20, 0x22, 0x24, 0x26, 0x28, 0x2a, 0x2c, 0x2e,
         0x30, 0x32, 0x34, 0x36, 0x38, 0x3a, 0x3c, 0x3e, 0x40, 0x42, 0x44, 0x46,
         0x48, 0x4a, 0x4c, 0x4e, 0x50, 0x52, 0x54, 0x56, 0x58, 0x5a, 0x5c, 0x5e,
         0x60, 0x62, 0x64, 0x66, 0x68, 0x6a, 0x6c, 0x6e, 0x70, 0x72, 0x74, 0x76,
         0x78, 0x7a, 0x7c, 0x7e, 0x80, 0x82, 0x84, 0x86, 0x88, 0x8a, 0x8c, 0x8e,
         0x90, 0x92, 0x94, 0x96, 0x98, 0x9a, 0x9c, 0x9e, 0xa0, 0xa2, 0xa4, 0xa6,
         0xa8, 0xaa, 0xac, 0xae, 0xb0, 0xb2, 0xb4, 0xb6, 0xb8, 0xba, 0xbc, 0xbe,
         0xc0, 0xc2, 0xc4, 0xc6, 0xc8, 0xca, 0xcc, 0xce, 0xd0, 0xd2, 0xd4, 0xd6,
         0xd8, 0xda, 0xdc, 0xde, 0xe0, 0xe2, 0xe4, 0xe6, 0xe8, 0xea, 0xec, 0xee,
         0xf0, 0xf2, 0xf4, 0xf6, 0xf8, 0xfa, 0xfc, 0xfe, 0x1b, 0x19, 0x1f, 0x1d,
         0x13, 0x11, 0x17, 0x15, 0x0b, 0x09, 0x0f, 0x0d, 0x03, 0x01, 0x07, 0x05,
         0x3b, 0x39, 0x3f, 0x3d, 0x33, 0x31, 0x37, 0x35, 0x2b, 0x29, 0x2f, 0x2d,
         0x23, 0x21, 0x27, 0x25, 0x5b, 0x59, 0x5f, 0x5d, 0x53, 0x51, 0x57, 0x55,
         0x4b, 0x49, 0x4f, 0x4d, 0x43, 0x41, 0x47, 0x45, 0x7b, 0x79, 0x7f, 0x7d,
         0x73, 0x71, 0x77, 0x75, 0x6b, 0x69, 0x6f, 0x6d, 0x63, 0x61, 0x67, 0x65,
         0x9b, 0x99, 0x9f, 0x9d, 0x93, 0x91, 0x97, 0x95, 0x8b, 0x89, 0x8f, 0x8d,
         0x83, 0x81, 0x87, 0x85, 0xbb, 0xb9, 0xbf, 0xbd, 0xb3, 0xb1, 0xb7, 0xb5,
         0xab, 0xa9, 0xaf, 0xad, 0xa3, 0xa1, 0xa7, 0xa5, 0xdb, 0xd9, 0xdf, 0xdd,
         0xd3, 0xd1, 0xd7, 0xd5, 0xcb, 0xc9, 0xcf, 0xcd, 0xc3, 0xc1, 0xc7, 0xc5,
         0xfb, 0xf9, 0xff, 0xfd, 0xf3, 0xf1, 0xf7, 0xf5, 0xeb, 0xe9, 0xef, 0xed,
         0xe3, 0xe1, 0xe7, 0xe5},

         // mul 3
         {0x00, 0x03, 0x06, 0x05, 0x0c, 0x0f, 0x0a, 0x09, 0x18, 0x1b, 0x1e, 0x1d,
          0x14, 0x17, 0x12, 0x11, 0x30, 0x33, 0x36, 0x35, 0x3c, 0x3f, 0x3a, 0x39,
          0x28, 0x2b, 0x2e, 0x2d, 0x24, 0x27, 0x22, 0x21, 0x60, 0x63, 0x66, 0x65,
          0x6c, 0x6f, 0x6a, 0x69, 0x78, 0x7b, 0x7e, 0x7d, 0x74, 0x77, 0x72, 0x71,
          0x50, 0x53, 0x56, 0x55, 0x5c, 0x5f, 0x5a, 0x59, 0x48, 0x4b, 0x4e, 0x4d,
          0x44, 0x47, 0x42, 0x41, 0xc0, 0xc3, 0xc6, 0xc5, 0xcc, 0xcf, 0xca, 0xc9,
          0xd8, 0xdb, 0xde, 0xdd, 0xd4, 0xd7, 0xd2, 0xd1, 0xf0, 0xf3, 0xf6, 0xf5,
          0xfc, 0xff, 0xfa, 0xf9, 0xe8, 0xeb, 0xee, 0xed, 0xe4, 0xe7, 0xe2, 0xe1,
          0xa0, 0xa3, 0xa6, 0xa5, 0xac, 0xaf, 0xaa, 0xa9, 0xb8, 0xbb, 0xbe, 0xbd,
          0xb4, 0xb7, 0xb2, 0xb1, 0x90, 0x93, 0x96, 0x95, 0x9c, 0x9f, 0x9a, 0x99,
          0x88, 0x8b, 0x8e, 0x8d, 0x84, 0x87, 0x82, 0x81, 0x9b, 0x98, 0x9d, 0x9e,
          0x97, 0x94, 0x91, 0x92, 0x83, 0x80, 0x85, 0x86, 0x8f, 0x8c, 0x89, 0x8a,
          0xab, 0xa8, 0xad, 0xae, 0xa7, 0xa4, 0xa1, 0xa2, 0xb3, 0xb0, 0xb5, 0xb6,
          0xbf, 0xbc, 0xb9, 0xba, 0xfb, 0xf8, 0xfd, 0xfe, 0xf7, 0xf4, 0xf1, 0xf2,
          0xe3, 0xe0, 0xe5, 0xe6, 0xef, 0xec, 0xe9, 0xea, 0xcb, 0xc8, 0xcd, 0xce,
          0xc7, 0xc4, 0xc1, 0xc2, 0xd3, 0xd0, 0xd5, 0xd6, 0xdf, 0xdc, 0xd9, 0xda,
          0x5b, 0x58, 0x5d, 0x5e, 0x57, 0x54, 0x51, 0x52, 0x43, 0x40, 0x45, 0x46,
          0x4f, 0x4c, 0x49, 0x4a, 0x6b, 0x68, 0x6d, 0x6e, 0x67, 0x64, 0x61, 0x62,
          0x73, 0x70, 0x75, 0x76, 0x7f, 0x7c, 0x79, 0x7a, 0x3b, 0x38, 0x3d, 0x3e,
          0x37, 0x34, 0x31, 0x32, 0x23, 0x20, 0x25, 0x26, 0x2f, 0x2c, 0x29, 0x2a,
          0x0b, 0x08, 0x0d, 0x0e, 0x07, 0x04, 0x01, 0x02, 0x13, 0x10, 0x15, 0x16,
          0x1f, 0x1c, 0x19, 0x1a},

         {0},
         {0},
         {0},
         {0},
         {0},

         // mul 9
         {0x00, 0x09, 0x12, 0x1b, 0x24, 0x2d, 0x36, 0x3f, 0x48, 0x41, 0x5a, 0x53,
          0x6c, 0x65, 0x7e, 0x77, 0x90, 0x99, 0x82, 0x8b, 0xb4, 0xbd, 0xa6, 0xaf,
          0xd8, 0xd1, 0xca, 0xc3, 0xfc, 0xf5, 0xee, 0xe7, 0x3b, 0x32, 0x29, 0x20,
          0x1f, 0x16, 0x0d, 0x04, 0x73, 0x7a, 0x61, 0x68, 0x57, 0x5e, 0x45, 0x4c,
          0xab, 0xa2, 0xb9, 0xb0, 0x8f, 0x86, 0x9d, 0x94, 0xe3, 0xea, 0xf1, 0xf8,
          0xc7, 0xce, 0xd5, 0xdc, 0x76, 0x7f, 0x64, 0x6d, 0x52, 0x5b, 0x40, 0x49,
          0x3e, 0x37, 0x2c, 0x25, 0x1a, 0x13, 0x08, 0x01, 0xe6, 0xef, 0xf4, 0xfd,
          0xc2, 0xcb, 0xd0, 0xd9, 0xae, 0xa7, 0xbc, 0xb5, 0x8a, 0x83, 0x98, 0x91,
          0x4d, 0x44, 0x5f, 0x56, 0x69, 0x60, 0x7b, 0x72, 0x05, 0x0c, 0x17, 0x1e,
          0x21, 0x28, 0x33, 0x3a, 0xdd, 0xd4, 0xcf, 0xc6, 0xf9, 0xf0, 0xeb, 0xe2,
          0x95, 0x9c, 0x87, 0x8e, 0xb1, 0xb8, 0xa3, 0xaa, 0xec, 0xe5, 0xfe, 0xf7,
          0xc8, 0xc1, 0xda, 0xd3, 0xa4, 0xad, 0xb6, 0xbf, 0x80, 0x89, 0x92, 0x9b,
          0x7c, 0x75, 0x6e, 0x67, 0x58, 0x51, 0x4a, 0x43, 0x34, 0x3d, 0x26, 0x2f,
          0x10, 0x19, 0x02, 0x0b, 0xd7, 0xde, 0xc5, 0xcc, 0xf3, 0xfa, 0xe1, 0xe8,
          0x9f, 0x96, 0x8d, 0x84, 0xbb, 0xb2, 0xa9, 0xa0, 0x47, 0x4e, 0x55, 0x5c,
          0x63, 0x6a, 0x71, 0x78, 0x0f, 0x06, 0x1d, 0x14, 0x2b, 0x22, 0x39, 0x30,
          0x9a, 0x93, 0x88, 0x81, 0xbe, 0xb7, 0xac, 0xa5, 0xd2, 0xdb, 0xc0, 0xc9,
          0xf6, 0xff, 0xe4, 0xed, 0x0a, 0x03, 0x18, 0x11, 0x2e, 0x27, 0x3c, 0x35,
          0x42, 0x4b, 0x50, 0x59, 0x66, 0x6f, 0x74, 0x7d, 0xa1, 0xa8, 0xb3, 0xba,
          0x85, 0x8c, 0x97, 0x9e, 0xe9, 0xe0, 0xfb, 0xf2, 0xcd, 0xc4, 0xdf, 0xd6,
          0x31, 0x38, 0x23, 0x2a, 0x15, 0x1c, 0x07, 0x0e, 0x79, 0x70, 0x6b, 0x62,
          0x5d, 0x54, 0x4f, 0x46},

         {0},

         // mul 11
         {0x00, 0x0b, 0x16, 0x1d, 0x2c, 0x27, 0x3a, 0x31, 0x58, 0x53, 0x4e, 0x45,
          0x74, 0x7f, 0x62, 0x69, 0xb0, 0xbb, 0xa6, 0xad, 0x9c, 0x97, 0x8a, 0x81,
          0xe8, 0xe3, 0xfe, 0xf5, 0xc4, 0xcf, 0xd2, 0xd9, 0x7b, 0x70, 0x6d, 0x66,
          0x57, 0x5c, 0x41, 0x4a, 0x23, 0x28, 0x35, 0x3e, 0x0f, 0x04, 0x19, 0x12,
          0xcb, 0xc0, 0xdd, 0xd6, 0xe7, 0xec, 0xf1, 0xfa, 0x93, 0x98, 0x85, 0x8e,
          0xbf, 0xb4, 0xa9, 0xa2, 0xf6, 0xfd, 0xe0, 0xeb, 0xda, 0xd1, 0xcc, 0xc7,
          0xae, 0xa5, 0xb8, 0xb3, 0x82, 0x89, 0x94, 0x9f, 0x46, 0x4d, 0x50, 0x5b,
          0x6a, 0x61, 0x7c, 0x77, 0x1e, 0x15, 0x08, 0x03, 0x32, 0x39, 0x24, 0x2f,
          0x8d, 0x86, 0x9b, 0x90, 0xa1, 0xaa, 0xb7, 0xbc, 0xd5, 0xde, 0xc3, 0xc8,
          0xf9, 0xf2, 0xef, 0xe4, 0x3d, 0x36, 0x2b, 0x20, 0x11, 0x1a, 0x07, 0x0c,
          0x65, 0x6e, 0x73, 0x78, 0x49, 0x42, 0x5f, 0x54, 0xf7, 0xfc, 0xe1, 0xea,
          0xdb, 0xd0, 0xcd, 0xc6, 0xaf, 0xa4, 0xb9, 0xb2, 0x83, 0x88, 0x95, 0x9e,
          0x47, 0x4c, 0x51, 0x5a, 0x6b, 0x60, 0x7d, 0x76, 0x1f, 0x14, 0x09, 0x02,
          0x33, 0x38, 0x25, 0x2e, 0x8c, 0x87, 0x9a, 0x91, 0xa0, 0xab, 0xb6, 0xbd,
          0xd4, 0xdf, 0xc2, 0xc9, 0xf8, 0xf3, 0xee, 0xe5, 0x3c, 0x37, 0x2a, 0x21,
          0x10, 0x1b, 0x06, 0x0d, 0x64, 0x6f, 0x72, 0x79, 0x48, 0x43, 0x5e, 0x55,
          0x01, 0x0a, 0x17, 0x1c, 0x2d, 0x26, 0x3b, 0x30, 0x59, 0x52, 0x4f, 0x44,
          0x75, 0x7e, 0x63, 0x68, 0xb1, 0xba, 0xa7, 0xac, 0x9d, 0x96, 0x8b, 0x80,
          0xe9, 0xe2, 0xff, 0xf4, 0xc5, 0xce, 0xd3, 0xd8, 0x7a, 0x71, 0x6c, 0x67,
          0x56, 0x5d, 0x40, 0x4b, 0x22, 0x29, 0x34, 0x3f, 0x0e, 0x05, 0x18, 0x13,
          0xca, 0xc1, 0xdc, 0xd7, 0xe6, 0xed, 0xf0, 0xfb, 0x92, 0x99, 0x84, 0x8f,
          0xbe, 0xb5, 0xa8, 0xa3},

         {0},

         // mul 13
         {0x00, 0x0d, 0x1a, 0x17, 0x34, 0x39, 0x2e, 0x23, 0x68, 0x65, 0x72, 0x7f,
          0x5c, 0x51, 0x46, 0x4b, 0xd0, 0xdd, 0xca, 0xc7, 0xe4, 0xe9, 0xfe, 0xf3,
          0xb8, 0xb5, 0xa2, 0xaf, 0x8c, 0x81, 0x96, 0x9b, 0xbb, 0xb6, 0xa1, 0xac,
          0x8f, 0x82, 0x95, 0x98, 0xd3, 0xde, 0xc9, 0xc4, 0xe7, 0xea, 0xfd, 0xf0,
          0x6b, 0x66, 0x71, 0x7c, 0x5f, 0x52, 0x45, 0x48, 0x03, 0x0e, 0x19, 0x14,
          0x37, 0x3a, 0x2d, 0x20, 0x6d, 0x60, 0x77, 0x7a, 0x59, 0x54, 0x43, 0x4e,
          0x05, 0x08, 0x1f, 0x12, 0x31, 0x3c, 0x2b, 0x26, 0xbd, 0xb0, 0xa7, 0xaa,
          0x89, 0x84, 0x93, 0x9e, 0xd5, 0xd8, 0xcf, 0xc2, 0xe1, 0xec, 0xfb, 0xf6,
          0xd6, 0xdb, 0xcc, 0xc1, 0xe2, 0xef, 0xf8, 0xf5, 0xbe, 0xb3, 0xa4, 0xa9,
          0x8a, 0x87, 0x90, 0x9d, 0x06, 0x0b, 0x1c, 0x11, 0x32, 0x3f, 0x28, 0x25,
          0x6e, 0x63, 0x74, 0x79, 0x5a, 0x57, 0x40, 0x4d, 0xda, 0xd7, 0xc0, 0xcd,
          0xee, 0xe3, 0xf4, 0xf9, 0xb2, 0xbf, 0xa8, 0xa5, 0x86, 0x8b, 0x9c, 0x91,
          0x0a, 0x07, 0x10, 0x1d, 0x3e, 0x33, 0x24, 0x29, 0x62, 0x6f, 0x78, 0x75,
          0x56, 0x5b, 0x4c, 0x41, 0x61, 0x6c, 0x7b, 0x76, 0x55, 0x58, 0x4f, 0x42,
          0x09, 0x04, 0x13, 0x1e, 0x3d, 0x30, 0x27, 0x2a, 0xb1, 0xbc, 0xab, 0xa6,
          0x85, 0x88, 0x9f, 0x92, 0xd9, 0xd4, 0xc3, 0xce, 0xed, 0xe0, 0xf7, 0xfa,
          0xb7, 0xba, 0xad, 0xa0, 0x83, 0x8e, 0x99, 0x94, 0xdf, 0xd2, 0xc5, 0xc8,
          0xeb, 0xe6, 0xf1, 0xfc, 0x67, 0x6a, 0x7d, 0x70, 0x53, 0x5e, 0x49, 0x44,
          0x0f, 0x02, 0x15, 0x18, 0x3b, 0x36, 0x21, 0x2c, 0x0c, 0x01, 0x16, 0x1b,
          0x38, 0x35, 0x22, 0x2f, 0x64, 0x69, 0x7e, 0x73, 0x50, 0x5d, 0x4a, 0x47,
          0xdc, 0xd1, 0xc6, 0xcb, 0xe8, 0xe5, 0xf2, 0xff, 0xb4, 0xb9, 0xae, 0xa3,
          0x80, 0x8d, 0x9a, 0x97},

          // mul 14
          {0x00, 0x0e, 0x1c, 0x12, 0x38, 0x36, 0x24, 0x2a, 0x70, 0x7e, 0x6c, 0x62,
           0x48, 0x46, 0x54, 0x5a, 0xe0, 0xee, 0xfc, 0xf2, 0xd8, 0xd6, 0xc4, 0xca,
           0x90, 0x9e, 0x8c, 0x82, 0xa8, 0xa6, 0xb4, 0xba, 0xdb, 0xd5, 0xc7, 0xc9,
           0xe3, 0xed, 0xff, 0xf1, 0xab, 0xa5, 0xb7, 0xb9, 0x93, 0x9d, 0x8f, 0x81,
           0x3b, 0x35, 0x27, 0x29, 0x03, 0x0d, 0x1f, 0x11, 0x4b, 0x45, 0x57, 0x59,
           0x73, 0x7d, 0x6f, 0x61, 0xad, 0xa3, 0xb1, 0xbf, 0x95, 0x9b, 0x89, 0x87,
           0xdd, 0xd3, 0xc1, 0xcf, 0xe5, 0xeb, 0xf9, 0xf7, 0x4d, 0x43, 0x51, 0x5f,
           0x75, 0x7b, 0x69, 0x67, 0x3d, 0x33, 0x21, 0x2f, 0x05, 0x0b, 0x19, 0x17,
           0x76, 0x78, 0x6a, 0x64, 0x4e, 0x40, 0x52, 0x5c, 0x06, 0x08, 0x1a, 0x14,
           0x3e, 0x30, 0x22, 0x2c, 0x96, 0x98, 0x8a, 0x84, 0xae, 0xa0, 0xb2, 0xbc,
           0xe6, 0xe8, 0xfa, 0xf4, 0xde, 0xd0, 0xc2, 0xcc, 0x41, 0x4f, 0x5d, 0x53,
           0x79, 0x77, 0x65, 0x6b, 0x31, 0x3f, 0x2d, 0x23, 0x09, 0x07, 0x15, 0x1b,
           0xa1, 0xaf, 0xbd, 0xb3, 0x99, 0x97, 0x85, 0x8b, 0xd1, 0xdf, 0xcd, 0xc3,
           0xe9, 0xe7, 0xf5, 0xfb, 0x9a, 0x94, 0x86, 0x88, 0xa2, 0xac, 0xbe, 0xb0,
           0xea, 0xe4, 0xf6, 0xf8, 0xd2, 0xdc, 0xce, 0xc0, 0x7a, 0x74, 0x66, 0x68,
           0x42, 0x4c, 0x5e, 0x50, 0x0a, 0x04, 0x16, 0x18, 0x32, 0x3c, 0x2e, 0x20,
           0xec, 0xe2, 0xf0, 0xfe, 0xd4, 0xda, 0xc8, 0xc6, 0x9c, 0x92, 0x80, 0x8e,
           0xa4, 0xaa, 0xb8, 0xb6, 0x0c, 0x02, 0x10, 0x1e, 0x34, 0x3a, 0x28, 0x26,
           0x7c, 0x72, 0x60, 0x6e, 0x44, 0x4a, 0x58, 0x56, 0x37, 0x39, 0x2b, 0x25,
           0x0f, 0x01, 0x13, 0x1d, 0x47, 0x49, 0x5b, 0x55, 0x7f, 0x71, 0x63, 0x6d,
           0xd7, 0xd9, 0xcb, 0xc5, 0xef, 0xe1, 0xf3, 0xfd, 0xa7, 0xa9, 0xbb, 0xb5,
           0x9f, 0x91, 0x83, 0x8d} };

    // init the array with 0s
    memset(newMat, 0, sizeof(newMat[0][0])* BLOCK_SIZE_ROW* BLOCK_SIZE_ROW);

    for (int i = 0; i < BLOCK_SIZE_ROW; i++)
    {
        for (int j = 0; j < BLOCK_SIZE_ROW; j++)
        {
            for (int k = 0; k < BLOCK_SIZE_ROW; k++)
            {
                if (mixColMat[i][j] == 1) // if it is 1 we dont need to multiply or anything
                {
                    newMat[i][k] ^= arr[j][k];
                }
                else
                {
                    // we have to use table here to do the byte multiplication correctly
                    newMat[i][k] ^= gfMulTable[mixColMat[i][j]][arr[j][k]];
                }
            }
        }
    }
}


/*
Creates a round key for a specific round
input: key - 2d int array(4x4 matrix) - the key that will be used at the beginning with the RotWord, roundNumber - the number of the round(needed for the RCON), final_round_key(the 2d arr to save the new round key inside, the result)
output: none(saving the output, result, in the final_round_key 2d array)
*/
void KeySchedule(unsigned int key[BLOCK_SIZE_ROW][BLOCK_SIZE_COLUMN], unsigned int roundNumber, unsigned int final_round_key[BLOCK_SIZE_ROW][BLOCK_SIZE_COLUMN])
{
    unsigned int rotWord[BLOCK_SIZE_ROW][BLOCK_SIZE_COLUMN] = { 0 }; // creating it 4x4 and not 1x4 so you can call SubBytes
    unsigned int roundConstant[KEY_ROUND_AMOUNT] = { 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36 };

	for (int i = 0; i < BLOCK_SIZE_COLUMN; i++) // Creating a swapped column of the Key(first stage of key schedule)
    { 
		if (i == BLOCK_SIZE_COLUMN - 1) 
        {
			rotWord[i][0] = key[0][3];
			break;
		}
        rotWord[i][0] = key[i + 1][3];
	}
	// second step of KeySchedule, sub bytes the RotWord:
	AES_Subbytes(rotWord, 1);

	// second step of KeySchedule, XOR the "new" rotWord with the "original" key left column and then xor it with the round constant(RCON):
	for (int i = 0; i < BLOCK_SIZE_COLUMN; i++) // xoring the RotWord with the Key left column and the RCON
    {
        rotWord[i][0] ^= key[i][0];
		rotWord[i][0] ^= roundConstant[roundNumber-1];
		final_round_key[i][0] = rotWord[i][0]; // the first(on the left) column of the final round key is the same of Rot Word after the manipulation we are doing on it
	}

	// third step of KeySchedule, running in a for loop and creating the "final" round key
	for (int column = 1; column < BLOCK_SIZE_COLUMN; column++) // we are starting from the second column because the first one(counting from the left) is the Rot Word after manipulation
    { 
		for (int row = 0; row < BLOCK_SIZE_ROW; row++) 
        {
			final_round_key[row][column] = (final_round_key[row][column - 1]) ^ key[row][column]; // column -1 because we are using the previous final round column we created
		}
	}
}

/*
AES addRoundKey function, XORs between a data block and the round key
input: data - 2d array of 4x4 data matrix, roundkey-2d array of the current round key
output: none(changed are applied to the data 2d array, therefore saving it on the same 2d array. no need in return)
*/
void AES_AddRoundKey(unsigned int data[BLOCK_SIZE_ROW][BLOCK_SIZE_COLUMN], unsigned int roundKey[BLOCK_SIZE_ROW][BLOCK_SIZE_COLUMN])
{
    for (int column = 0; column < BLOCK_SIZE_COLUMN; column++)
    {
        for (int row = 0; row < BLOCK_SIZE_ROW; row++)
        {
            data[row][column] ^= roundKey[row][column];
        }
    }
}


/*
* PLEASE NOTE THAT THIS IS NOT THE FINAL ENCRYPTING FUNCTION - IT ONLY ENCRYPTS A BLOCK IN 4X4 SIZE! WHICH WILL BE USED IN THE FINAL ENCRYPTION
Takes data in needed size(128 bits / 16 bytes) and encrypts it using AES - CBC ENCRYPTION MODE CHOSEN
input: data(2d int arr), iv
output: encrypted AES data
*/
void encrypt_data_AES(unsigned int data[BLOCK_SIZE_ROW][BLOCK_SIZE_COLUMN],
    unsigned int iv[BLOCK_SIZE_ROW][BLOCK_SIZE_COLUMN], unsigned int roundKey[BLOCK_SIZE_ROW][BLOCK_SIZE_COLUMN], unsigned int isLastRound)
{
    unsigned int data_after_mix[BLOCK_SIZE_ROW][BLOCK_SIZE_COLUMN] = { 0 };

    // first of all we have to XOR the data with the IV
    XOR_Blocks(data, iv);

    // second stage of the encryption is to send the XORed data to the AES functions. Let's start with the Sub Bytes(first AES stage)
    AES_Subbytes(data, 0); // sending 0 because we need al the data to be XORed

    // third stage of the encryption is to call the Shift Rows function
    AES_ShiftRows(data);

    // fourth stage of the encryption is to call the Mix Columns function
    if (!isLastRound) // we dont do mixcolumns in last round
    {
        AES_MixColumns(data, data_after_mix, 0);
        memcpy(data, data_after_mix, sizeof(int) * BLOCK_SIZE_COLUMN * BLOCK_SIZE_ROW);
    }

    // final stage of the block encryption process
    AES_AddRoundKey(data, roundKey);
}

/*
* PLEASE NOTE THAT THIS IS NOT THE FINAL DECRYPTING FUNCTION - IT ONLY DECRYPTS A BLOCK IN 4X4 SIZE! WHICH WILL BE USED IN THE FINAL DECRYPTION
The function will decrypt a 4x4(16 bytes) data block using AES encryption
input: data - 4x4 2d data array, iv - 2d data array, roundkey(will be used in add round key) 2d array
output: none, saved in data array
*/
void decrypt_data_AES(unsigned int data[BLOCK_SIZE_ROW][BLOCK_SIZE_COLUMN],
    unsigned int iv[BLOCK_SIZE_ROW][BLOCK_SIZE_COLUMN], unsigned int roundkey[BLOCK_SIZE_ROW][BLOCK_SIZE_COLUMN], unsigned int isLastRound)
{
    unsigned int data_after_mix[BLOCK_SIZE_ROW][BLOCK_SIZE_COLUMN] = { 0 };

    AES_AddRoundKey(data, roundkey); // first stage of decryption is the AddRoundKey function
    if (!isLastRound) { // mix columns is skipped on last round of AES
        AES_MixColumns(data, data_after_mix, 1); // second stage of decrpytion is the Inverse 
        memcpy(data, data_after_mix, sizeof(int) * BLOCK_SIZE_COLUMN * BLOCK_SIZE_ROW);
    }
    AES_InvShiftRows(data); // third stage of decryption is ShiftRows
    AES_inv_Subbytes(data); // fourth stage of decryption is inversed Sub bytes

    // last stage is to XOR with the IV!
    XOR_Blocks(data, iv);
}


/*
Encrypting a given file
input: file path
output: none
*/
void encryptDecryptFile(char fileName[], unsigned int key[BLOCK_SIZE_ROW][BLOCK_SIZE_COLUMN], unsigned int iv[BLOCK_SIZE_ROW][BLOCK_SIZE_COLUMN],
    unsigned int isEncrypt)
{
    DWORD fileSize = 0;
    DWORD bytesRead = 0;
    OFSTRUCT buffer = { 0 };

    HFILE hFile = OpenFile(fileName, &buffer, OF_READWRITE); // opening file in read and write just in case we need to do padding
    
    unsigned char* data;
    unsigned char* encData;
    unsigned char currBytes[BLOCK_SIZE + 1] = { 0 };
    unsigned char tmp[BLOCK_SIZE + 1] = { 0 };

    unsigned int prevCipheredBlock[BLOCK_SIZE_ROW][BLOCK_SIZE_COLUMN] = { 0 };
    unsigned int bytes2DArr[BLOCK_SIZE_ROW][BLOCK_SIZE_COLUMN] = { 0 };

    fileSize = GetFileSize((HANDLE)hFile, NULL);

    if (fileSize % BLOCK_SIZE != 0)  // checking if the file needs padding
    { 
        int numToAdd = 0;
        numToAdd = fileSize < BLOCK_SIZE ? (BLOCK_SIZE - fileSize) : (BLOCK_SIZE- (fileSize % BLOCK_SIZE)); // determining the padding size
        addPaddingToFileEnding((HANDLE)hFile, numToAdd);
        hFile = OpenFile(fileName, &buffer, OF_READWRITE);
        fileSize += (numToAdd);
    }
    printf("\nStarting to encrypt/decrypt file of size: %d\n", fileSize);

    data = (unsigned char*)malloc(sizeof(char) * (fileSize + 1)); // allocating space for the data to be read    
    encData = (unsigned char*)malloc(sizeof(char) * (fileSize + 1));

    if (!(ReadFile((HANDLE)hFile, data, fileSize, &bytesRead, NULL)))
    {
        perror("couldn't read file!");
        _exit(0);
    }
   
    memcpy(prevCipheredBlock, iv, sizeof(int) * BLOCK_SIZE); // prevCipheredBlock = iv

    for (int i = 0; i < fileSize / BLOCK_SIZE; i++)
    {
        memcpy(currBytes, data + (i * BLOCK_SIZE), BLOCK_SIZE); // copying the current block we need to encrypt to the currBytes array which we will encrypt
       
        memcpy(tmp, currBytes, BLOCK_SIZE);
        BytesTo_2DArr(currBytes, bytes2DArr);

        if (isEncrypt) encrypt_block(prevCipheredBlock, bytes2DArr, key);
        else decrypt_block(prevCipheredBlock, bytes2DArr, key);
        
        _2DArrTo_Bytes(currBytes, bytes2DArr);
        
        memcpy(encData + (i * BLOCK_SIZE), currBytes, BLOCK_SIZE); // copying enc/dec data into the encData which will be written to the file later

        if (!isEncrypt) { // if we are decrypting we want the prev block to be cipher! and the prev block will be prev plain if we don't put this condition
            BytesTo_2DArr(tmp, bytes2DArr);
        }
        memcpy(prevCipheredBlock, bytes2DArr, sizeof(int) * BLOCK_SIZE); // saving previous block
    }


    CloseHandle((HANDLE)hFile); // closing the file handle
    DeleteFileA(fileName); // Deleting the older file and writing a new file with the same name and encrypted content
    
    writeNewEncData(fileName, encData, fileSize, isEncrypt);

    printf("\nFinished encrypting/decrypting file.");

    free(data); // FREE ONLY FOR NOW, ILL USE IT LATER
    free(encData);
}


/*
Function preforms all AES encryption operations on a single block of data (16 bytes) and creates a new round key accordingly
Input: previous block(to xor), the block which we want to encrypt, current key
Output: none
*/
void encrypt_block(unsigned int prevBlock[BLOCK_SIZE_ROW][BLOCK_SIZE_ROW], unsigned int currBlock[BLOCK_SIZE_ROW][BLOCK_SIZE_ROW], unsigned int key[BLOCK_SIZE_ROW][BLOCK_SIZE_ROW])
{
    unsigned int roundKey[BLOCK_SIZE_ROW][BLOCK_SIZE_ROW];

    for (int r = 1; r < 11; r++)
    {
        KeySchedule(key, r, roundKey);
        encrypt_data_AES(currBlock, prevBlock, roundKey, r == 9);
    }
}

/*
Function preforms all AES decryption operations on a single block of data (16 bytes)
Input: previous block(to xor), the block which we want to encrypt, current key
Output: none
*/
void decrypt_block(unsigned int prevBlock[BLOCK_SIZE_ROW][BLOCK_SIZE_ROW], unsigned int currBlock[BLOCK_SIZE_ROW][BLOCK_SIZE_ROW], unsigned int key[BLOCK_SIZE_ROW][BLOCK_SIZE_ROW])
{
    unsigned int roundKey[BLOCK_SIZE_ROW][BLOCK_SIZE_COLUMN];

    for (int r = 10; r > 0; r--)
    {
        KeySchedule(key, r, roundKey);
        decrypt_data_AES(currBlock, prevBlock, roundKey, r == 9);
    }
}


/*
Adding padding to a file in order to encrypt it
input: file Handler, num of zeros to add in the end of the file
output: none
*/
void addPaddingToFileEnding(HANDLE fileHandler, unsigned int amountOfZerosToAdd)
{
    // The following lines are converting HANDLE to FILE*
    int nHandle = _open_osfhandle((long)fileHandler, _O_APPEND);
    if (nHandle == -1) 
    {
        CloseHandle(fileHandler);
        _exit(0);
    }

    FILE* fp = _fdopen(nHandle, "a");

    if (!fp) 
    {
        CloseHandle(fileHandler);
        _exit(0);
    }

    // padding the file with NULL
    printf("ZEROS TO ADD: %d\n",amountOfZerosToAdd);

    for (int i = 0; i < amountOfZerosToAdd; i++) 
    {
        if (fputc('\0', fp) == EOF) 
        {
            perror("file padding was corrupted!");
        }
    }
    fclose(fp);
}

/*
Writes a new file with the data sent as param
input: fileName - name of file to create, dataToWrite-data to write into the file, bytesToWrite- how much bytes should be written, isEncrypt - 0/1 to check if we need to remove padding
output: none
*/
void writeNewEncData(char* fileName, unsigned char* dataToWrite, unsigned int bytesToWrite, int isEncrypt)
{
    FILE* pfile = NULL;
    errno_t err = fopen_s(&pfile, fileName, "wb");

    int numOfPadding = 0, size = 0;

    if (pfile == NULL) 
    {
        printf("error opening file!");
        _exit(1);
    }

    for (int i = 0; i < bytesToWrite; i++)
    {
        if (dataToWrite[i] == 0)
        {
            numOfPadding++; // counting the amount of padding added to the file so we can remove it later
        }
        else 
        {
            numOfPadding = 0;
        }
        size++;
        fputc(dataToWrite[i], pfile);
    }
    fclose(pfile);

    if (!isEncrypt) // this checks if we need to remove padding
    { 
        int file = _open(fileName,O_WRONLY);
        _chsize(file, size - numOfPadding); // resize the file therefore "removing" its padding we added before encryption
    }
}


/*
Function performs XOR operation between 2 2d arrays
Input: 2 2d arrays
Output: none
*/
void XOR_Blocks(unsigned int arr[BLOCK_SIZE_ROW][BLOCK_SIZE_ROW], unsigned int arr2[BLOCK_SIZE_ROW][BLOCK_SIZE_ROW])
{
    for (int i = 0; i < BLOCK_SIZE_ROW; i++)
    {
        for (int j = 0; j < BLOCK_SIZE_COLUMN; j++)
        {
            arr[i][j] ^= arr2[i][j];
        }
    }
}


/*
Converts a char array of bytes that we get from the file reading to a 2d array of bytes that we can work with
Input: char array of bytes, 2d array
Output: none
*/
void BytesTo_2DArr(unsigned char* bytes, unsigned int arr[BLOCK_SIZE_ROW][BLOCK_SIZE_COLUMN])
{
    for (int i = 0; i < BLOCK_SIZE_ROW; i++) 
    {
        for (int j = 0; j < BLOCK_SIZE_COLUMN; j++) 
        {
            arr[i][j] = bytes[i * BLOCK_SIZE_ROW + j];
        }
    }
}

/*
Converts a 2d array to a char array of bytes so we can write to the file
Input: char array of bytes, 2d array
Output: none
*/
void _2DArrTo_Bytes(unsigned char* bytes, unsigned int arr[BLOCK_SIZE_ROW][BLOCK_SIZE_COLUMN])
{
    for (int i = 0; i < BLOCK_SIZE_ROW; i++)
    {
        for (int j = 0; j < BLOCK_SIZE_COLUMN; j++)
        {
            bytes[i * BLOCK_SIZE_ROW + j] = arr[i][j];
        }
    }
}
